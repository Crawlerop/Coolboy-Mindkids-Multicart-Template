;
; File generated by cc65 v 2.19 - Git f8cdb2a
;
	.fopt		compiler,"cc65 v 2.19 - Git f8cdb2a"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_bg
	.import		_pal_spr
	.import		_pal_clear
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_oam_spr
	.import		_pad_poll
	.import		_bank_spr
	.import		_bank_bg
	.import		_rand8
	.import		_set_rand
	.import		_vram_adr
	.import		_vram_fill
	.import		_vram_write
	.import		_memcpy
	.import		_memfill
	.import		_set_vram_buffer
	.import		_multi_vram_buffer_horz
	.import		_multi_vram_buffer_vert
	.import		_get_pad_new
	.import		_flush_vram_update2
	.export		_bankLevel
	.export		_bankBuffer
	.export		_banked_call
	.export		_bank_push
	.export		_bank_pop
	.import		_set_prg_8000
	.import		_set_chr_mode_0
	.import		_set_chr_mode_1
	.import		_set_chr_mode_2
	.import		_set_chr_mode_3
	.import		_set_chr_mode_4
	.import		_set_chr_mode_5
	.import		_set_mirroring
	.import		_set_wram_mode
	.import		_set_extended_gfx
	.import		_disable_irq
	.export		_NUM_0
	.export		_NUM_1
	.export		_NUM_2
	.export		_NUM_3
	.export		_NUM_4
	.export		_NUM_5
	.export		_NUM_6
	.export		_NUM_7
	.export		_NUM_8
	.export		_NUM_9
	.export		_NUM_IN
	.export		_NUM_UNKNOWN
	.export		_Numbers
	.export		_Numbers_Length
	.export		_CAT_1_GAMES_TEXT
	.export		_CAT_2_EXTRA_TEXT
	.export		_CAT_NO
	.export		_CAT_SHF
	.export		_CAT_TXT
	.export		_pad1
	.export		_pad1_new
	.export		_text_offs
	.export		_dig_offset
	.export		_cart_inserted
	.export		_game_offset
	.export		_gfx_offset
	.export		_gfx_bank_offset
	.export		_title_buffer
	.export		_sram_offset
	.export		_checking_sram
	.export		_sram_expected
	.export		_irq_array
	.export		_counter
	.export		_line
	.export		_delay_s
	.export		_tmp_digit
	.export		_digits
	.export		_menu_offset
	.export		_menu_hold_delay
	.export		_page
	.export		_m_d
	.export		_ar_pos
	.export		_ar_del
	.export		_text_tmp
	.export		_text_tmp_i
	.export		_x_pos_t
	.export		_x_pos_tl
	.export		_x_pos_ch
	.export		_MAXGAME
	.export		_rom_shift
	.export		_rom_name_offset
	.export		_bank_temp_8000
	.export		_d_cat
	.export		_s_delay
	.export		_MenuPal
	.export		_MenuPal_S
	.export		_IDENT
	.export		_COMPILE_DATE
	.export		_COMPILE_TIME
	.export		_blank
	.export		_startup_attr
	.export		_DrawPage
	.export		_DrawText
	.import		_StartGame
	.export		_TestMode
	.import		_PlaySnd
	.export		_IsCartridgeInserted
	.export		_ClearCHRBlock
	.export		_RunGame
	.export		_render_title
	.export		_ClearCHR
	.export		_LoadGFX
	.export		_LoadCat
	.export		_main

.segment	"DATA"

_digits:
	.byte	$30
	.byte	$30
	.byte	$30
	.byte	$2E
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_MAXGAME:
	.word	$00C8
_rom_shift:
	.word	$0000
_s_delay:
	.byte	$08

.segment	"RODATA"

.segment	"STARTUP"
_NUM_0:
	.byte	$20
	.byte	$21
	.byte	$22
	.byte	$24
	.byte	$25
	.byte	$26
	.byte	$28
	.byte	$29
	.byte	$2A
_NUM_1:
	.byte	$18
	.byte	$19
	.byte	$1A
	.byte	$1C
	.byte	$1D
	.byte	$1E
_NUM_2:
	.byte	$0F
	.byte	$4C
	.byte	$4D
	.byte	$13
	.byte	$50
	.byte	$51
	.byte	$17
	.byte	$54
	.byte	$55
_NUM_3:
	.byte	$1B
	.byte	$58
	.byte	$59
	.byte	$1F
	.byte	$5C
	.byte	$5D
	.byte	$23
	.byte	$60
	.byte	$61
_NUM_4:
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$04
	.byte	$05
	.byte	$06
	.byte	$08
	.byte	$09
	.byte	$0A
_NUM_5:
	.byte	$0C
	.byte	$0D
	.byte	$0E
	.byte	$10
	.byte	$11
	.byte	$12
	.byte	$14
	.byte	$15
	.byte	$16
_NUM_6:
	.byte	$03
	.byte	$40
	.byte	$41
	.byte	$07
	.byte	$44
	.byte	$45
	.byte	$0B
	.byte	$48
	.byte	$49
_NUM_7:
	.byte	$27
	.byte	$64
	.byte	$65
	.byte	$2B
	.byte	$68
	.byte	$69
	.byte	$2F
	.byte	$6C
	.byte	$6D
_NUM_8:
	.byte	$33
	.byte	$70
	.byte	$71
	.byte	$37
	.byte	$74
	.byte	$75
	.byte	$3B
	.byte	$78
	.byte	$79
_NUM_9:
	.byte	$42
	.byte	$43
	.byte	$46
	.byte	$47
	.byte	$4A
	.byte	$4B
	.byte	$4E
	.byte	$4F
	.byte	$52
_NUM_IN:
	.byte	$2C
	.byte	$2D
	.byte	$2E
	.byte	$30
	.byte	$31
	.byte	$32
	.byte	$34
	.byte	$35
	.byte	$36
	.byte	$38
	.byte	$39
	.byte	$3A
_NUM_UNKNOWN:
	.byte	$6A
	.byte	$6A
	.byte	$6A
	.res	3,$00
_Numbers:
	.addr	_NUM_0
	.addr	_NUM_1
	.addr	_NUM_2
	.addr	_NUM_3
	.addr	_NUM_4
	.addr	_NUM_5
	.addr	_NUM_6
	.addr	_NUM_7
	.addr	_NUM_8
	.addr	_NUM_9
	.addr	_NUM_UNKNOWN
_Numbers_Length:
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$01
_CAT_1_GAMES_TEXT:
	.byte	$32,$38,$32,$20,$49,$4E,$20,$31
_CAT_2_EXTRA_TEXT:
	.byte	$20,$31,$38,$20,$49,$4E,$20,$31
_CAT_NO:
	.word	$011A
	.word	$0012
_CAT_SHF:
	.word	$0000
	.word	$011A
_CAT_TXT:
	.addr	_CAT_1_GAMES_TEXT
	.addr	_CAT_2_EXTRA_TEXT
_MenuPal:
	.byte	$0F
	.byte	$30
	.byte	$1A
	.byte	$04
	.byte	$0F
	.byte	$11
	.byte	$1A
	.byte	$04
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
_MenuPal_S:
	.byte	$01
	.byte	$13
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
_IDENT:
	.byte	$44,$65,$76,$65,$6C,$6F,$70,$65,$64,$20,$75,$73,$69,$6E,$67,$20
	.byte	$4F,$70,$65,$6E,$4D,$75,$6C,$74,$69,$4C,$6F,$61,$64,$65,$72,$2C
	.byte	$20,$56,$65,$72,$73,$69,$6F,$6E,$20,$30,$2E,$31,$00
_COMPILE_DATE:
	.byte	$41,$70,$72,$20,$32,$33,$20,$32,$30,$32,$32,$00
_COMPILE_TIME:
	.byte	$31,$39,$3A,$32,$33,$3A,$34,$38,$00
.segment	"CODE"
_blank:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_startup_attr:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$55
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$55
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
S000F:
	.byte	$53,$52,$41,$4D,$20,$46,$41,$49,$4C,$00
S0010:
	.byte	$53,$52,$41,$4D,$20,$50,$41,$53,$53,$00
S000E:
	.byte	$52,$4F,$4D,$20,$54,$45,$53,$54,$00

.segment	"BSS"

_bankLevel:
	.res	1,$00
_bankBuffer:
	.res	10,$00
.segment	"ZEROPAGE"
_pad1:
	.res	1,$00
_pad1_new:
	.res	1,$00
_text_offs:
	.res	1,$00
_dig_offset:
	.res	1,$00
_cart_inserted:
	.res	1,$00
_game_offset:
	.res	2,$00
_gfx_offset:
	.res	2,$00
_gfx_bank_offset:
	.res	1,$00
_title_buffer:
	.res	4,$00
_sram_offset:
	.res	2,$00
_checking_sram:
	.res	1,$00
_sram_expected:
	.res	1,$00
.segment	"BSS"
_irq_array:
	.res	64,$00
_counter:
	.res	1,$00
_line:
	.res	1,$00
_delay_s:
	.res	1,$00
_tmp_digit:
	.res	2,$00
_menu_offset:
	.res	2,$00
_menu_hold_delay:
	.res	1,$00
_page:
	.res	1,$00
_m_d:
	.res	1,$00
_ar_pos:
	.res	1,$00
_ar_del:
	.res	1,$00
_text_tmp:
	.res	64,$00
_text_tmp_i:
	.res	64,$00
_x_pos_t:
	.res	1,$00
_x_pos_tl:
	.res	1,$00
_x_pos_ch:
	.res	1,$00
_rom_name_offset:
	.res	2,$00
_bank_temp_8000:
	.res	1,$00
_d_cat:
	.res	1,$00

; ---------------------------------------------------------------
; void __near__ banked_call (unsigned char bankId, void (*method)(void))
; ---------------------------------------------------------------

.segment	"STARTUP"

.proc	_banked_call: near

.segment	"STARTUP"

;
; void banked_call(unsigned char bankId, void (*method)(void)) {
;
	jsr     pushax
;
; bank_push(bankId);
;
	ldy     #$02
	lda     (sp),y
	jsr     _bank_push
;
; (*method)();
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     callax
;
; bank_pop();
;
	jsr     _bank_pop
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ bank_push (unsigned char bankId)
; ---------------------------------------------------------------

.segment	"STARTUP"

.proc	_bank_push: near

.segment	"STARTUP"

;
; void bank_push(unsigned char bankId) {
;
	jsr     pusha
;
; bankBuffer[bankLevel] = bankId;
;
	ldy     #$00
	lda     (sp),y
	ldy     _bankLevel
	sta     _bankBuffer,y
;
; ++bankLevel;
;
	inc     _bankLevel
;
; set_prg_8000(bankId);
;
	ldy     #$00
	lda     (sp),y
	jsr     _set_prg_8000
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ bank_pop (void)
; ---------------------------------------------------------------

.segment	"STARTUP"

.proc	_bank_pop: near

.segment	"STARTUP"

;
; --bankLevel;
;
	dec     _bankLevel
;
; if (bankLevel > 0) {
;
	beq     L0002
;
; set_prg_8000(bankBuffer[bankLevel-1]);
;
	ldx     #$00
	lda     _bankLevel
	sec
	sbc     #$01
	bcs     L0003
	dex
L0003:	sta     ptr1
	txa
	clc
	adc     #>(_bankBuffer)
	sta     ptr1+1
	ldy     #<(_bankBuffer)
	lda     (ptr1),y
	jmp     _set_prg_8000
;
; }
;
L0002:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ DrawPage (unsigned char page, unsigned char fast)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_DrawPage: near

.segment	"CODE"

;
; void DrawPage(unsigned char page, unsigned char fast) {  
;
	jsr     pusha
;
; if (!fast) {
;
	ldy     #$00
	lda     (sp),y
	bne     L0002
;
; set_vram_buffer();    
;
	jsr     _set_vram_buffer
;
; oam_clear();
;
	jsr     _oam_clear
;
; oam_spr(M_X, M_Y+(16*(menu_offset%MAXLINES)), ARR_OFFSET, 0x0);
;
	jsr     decsp3
	lda     #$30
	ldy     #$02
	sta     (sp),y
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$52
	ldy     #$01
	sta     (sp),y
	lda     #$B6
	dey
	sta     (sp),y
	tya
	jsr     _oam_spr
;
; oam_spr(M_X+8, M_Y+(16*(menu_offset%MAXLINES)), ARR_OFFSET+1, 0x0);
;
	jsr     decsp3
	lda     #$38
	ldy     #$02
	sta     (sp),y
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$52
	ldy     #$01
	sta     (sp),y
	lda     #$B7
	dey
	sta     (sp),y
	tya
	jsr     _oam_spr
;
; for (line = 0; line<MAXLINES; line++) {
;
L0002:	lda     #$00
	sta     _line
L002C:	lda     _line
	cmp     #$08
	jcs     L0006
;
; memfill(text_tmp_i, 0x0, sizeof(text_tmp_i));
;
	jsr     decsp3
	lda     #<(_text_tmp_i)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_text_tmp_i)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	tax
	lda     #$40
	jsr     _memfill
;
; tmp_digit = (MAXLINES*page)+line+1;  
;
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     shlax3
	clc
	adc     _line
	bcc     L0027
	inx
	clc
L0027:	adc     #$01
	bcc     L0009
	inx
L0009:	sta     _tmp_digit
	stx     _tmp_digit+1
;
; dig_offset = 2;
;
	lda     #$02
	sta     _dig_offset
;
; if (tmp_digit > MAXGAME) {
;
	lda     _tmp_digit
	sec
	sbc     _MAXGAME
	sta     tmp1
	lda     _tmp_digit+1
	sbc     _MAXGAME+1
	ora     tmp1
	bcc     L000A
	beq     L000A
;
; text_tmp_i[0] = 0x00;
;
	lda     #$00
	sta     _text_tmp_i
;
; text_tmp_i[1] = 0x00;
;
	sta     _text_tmp_i+1
;
; text_tmp_i[2] = 0x00;
;
	sta     _text_tmp_i+2
;
; text_tmp_i[3] = 0x00;
;
	sta     _text_tmp_i+3
;
; } else {   
;
	jmp     L000B
;
; digits[3] = 0x2e;               
;
L000A:	lda     #$2E
	sta     _digits+3
;
; digits[2] = (tmp_digit % 10) + 0x30;
;
	lda     _tmp_digit
	ldx     _tmp_digit+1
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	sta     _digits+2
;
; tmp_digit /= 10;   
;
	lda     _tmp_digit
	ldx     _tmp_digit+1
	jsr     pushax
	lda     #$0A
	jsr     tosudiva0
	sta     _tmp_digit
	stx     _tmp_digit+1
;
; digits[1] = (tmp_digit % 10) + 0x30;  
;
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	sta     _digits+1
;
; if (((MAXLINES*page)+line+1) >= 10) {
;
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     shlax3
	clc
	adc     _line
	bcc     L0028
	inx
	clc
L0028:	adc     #$01
	bcc     L000F
	inx
L000F:	cmp     #$0A
	txa
	sbc     #$00
	bvs     L0010
	eor     #$80
L0010:	bpl     L002D
;
; digits[1] = (tmp_digit % 10) + 0x30;            
;
	lda     _tmp_digit
	ldx     _tmp_digit+1
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
;
; } else {
;
	jmp     L0025
;
; dig_offset--;
;
L002D:	dec     _dig_offset
;
; digits[1] = 0x00;
;
	lda     #$00
L0025:	sta     _digits+1
;
; tmp_digit /= 10;
;
	lda     _tmp_digit
	ldx     _tmp_digit+1
	jsr     pushax
	lda     #$0A
	jsr     tosudiva0
	sta     _tmp_digit
	stx     _tmp_digit+1
;
; digits[0] = (tmp_digit % 10) + 0x30;
;
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	sta     _digits
;
; if (((MAXLINES*page)+line+1) >= 100) {
;
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     shlax3
	clc
	adc     _line
	bcc     L0029
	inx
	clc
L0029:	adc     #$01
	bcc     L0015
	inx
L0015:	cmp     #$64
	txa
	sbc     #$00
	bvs     L0016
	eor     #$80
L0016:	bpl     L002E
;
; digits[0] = (tmp_digit % 10) + 0x30;
;
	lda     _tmp_digit
	ldx     _tmp_digit+1
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
;
; } else {
;
	jmp     L0026
;
; dig_offset--;
;
L002E:	dec     _dig_offset
;
; digits[0] = 0x00;
;
	lda     #$00
L0026:	sta     _digits
;
; memcpy(text_tmp_i+dig_offset, digits, 4);
;
L000B:	lda     #<(_text_tmp_i)
	ldx     #>(_text_tmp_i)
	clc
	adc     _dig_offset
	bcc     L0019
	inx
L0019:	jsr     pushax
	lda     #<(_digits)
	ldx     #>(_digits)
	jsr     pushax
	ldx     #$00
	lda     #$04
	jsr     _memcpy
;
; if (tmp_digit > MAXGAME) {
;
	lda     _tmp_digit
	sec
	sbc     _MAXGAME
	sta     tmp1
	lda     _tmp_digit+1
	sbc     _MAXGAME+1
	ora     tmp1
	bcc     L001A
	beq     L001A
;
; memfill(text_tmp_i, 0x00, sizeof(text_tmp_i));
;
	jsr     decsp3
	lda     #<(_text_tmp_i)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_text_tmp_i)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	tax
	lda     #$40
	jsr     _memfill
;
; } else {
;
	jmp     L001B
;
; rom_name_offset = (16*(line+rom_shift)) + (16*MAXLINES)*page;
;
L001A:	lda     _line
	clc
	adc     _rom_shift
	pha
	lda     #$00
	adc     _rom_shift+1
	tax
	pla
	jsr     shlax4
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	ldy     #$01
	lda     (sp),y
	jsr     shlax4
	jsr     shlax3
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	sta     _rom_name_offset
	stx     _rom_name_offset+1
;
; set_prg_8000(rom_name_offset >= 0x2000 ? ROM_NAMES+1 : ROM_NAMES);
;
	cmp     #$00
	txa
	sbc     #$20
	bcc     L002F
	lda     #$3C
	jmp     L0030
L002F:	lda     #$3B
L0030:	jsr     _set_prg_8000
;
; memcpy(text_tmp_i+(dig_offset+4), &PEEK(0x8000 + (rom_name_offset % 0x2000)), 16);
;
	ldx     #$00
	lda     _dig_offset
	clc
	adc     #$04
	bcc     L002A
	inx
	clc
L002A:	adc     #<(_text_tmp_i)
	tay
	txa
	adc     #>(_text_tmp_i)
	tax
	tya
	jsr     pushax
	lda     _rom_name_offset+1
	and     #$1F
	tax
	lda     _rom_name_offset
	pha
	txa
	clc
	adc     #$80
	tax
	pla
	jsr     pushax
	ldx     #$00
	lda     #$10
	jsr     _memcpy
;
; DrawText(text_tmp_i+2, TEXT_LENGTH, NTADR_A(8,TEXT_OFFSET+(2*line)), fast);
;
L001B:	jsr     decsp5
	lda     #<(_text_tmp_i+2)
	ldy     #$03
	sta     (sp),y
	iny
	lda     #>(_text_tmp_i+2)
	sta     (sp),y
	lda     #$18
	ldy     #$02
	sta     (sp),y
	ldx     #$00
	lda     _line
	asl     a
	bcc     L002B
	inx
	clc
L002B:	adc     #$0A
	bcc     L001F
	inx
L001F:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	ora     #$08
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	ldy     #$00
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	ldy     #$05
	lda     (sp),y
	jsr     _DrawText
;
; if (!fast) ppu_wait_nmi();
;
	ldy     #$00
	lda     (sp),y
	bne     L0007
	jsr     _ppu_wait_nmi
;
; for (line = 0; line<MAXLINES; line++) {
;
L0007:	inc     _line
	jmp     L002C
;
; }
;
L0006:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ DrawText (unsigned char *text, unsigned char length, int address, unsigned char fast)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_DrawText: near

.segment	"CODE"

;
; void DrawText(unsigned char *text, unsigned char length, int address, unsigned char fast) {
;
	jsr     pusha
;
; memfill(text_tmp, 0, sizeof(text_tmp));
;
	jsr     decsp3
	lda     #<(_text_tmp)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_text_tmp)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	tax
	lda     #$40
	jsr     _memfill
;
; for (text_offs = 0; text_offs<length; text_offs++) {
;
	lda     #$00
	sta     _text_offs
L005E:	lda     _text_offs
	ldy     #$03
	cmp     (sp),y
	jcs     L0003
;
; if (text[text_offs] >= 0x30 && text[text_offs] <= 0x39) {
;
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$30
	bcc     L0006
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$3A
	bcs     L0006
;
; text_tmp[text_offs] = 2*(text[text_offs]-0x30)+0x20+CHARA_OFFSET;
;
	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	clc
	adc     _text_offs
	bcc     L000A
	inx
L000A:	sta     sreg
	stx     sreg+1
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$30
	bcs     L000B
	dex
L000B:	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #$20
;
; } else if (text[text_offs] >= 0x00 && text[text_offs] <= 0x1f) {
;
	jmp     L0074
L0006:	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$20
	bcs     L000F
;
; text_tmp[text_offs] = 0x00+CHARA_OFFSET;
;
	ldy     _text_offs
	lda     #$80
	sta     _text_tmp,y
;
; } else if (text[text_offs] >= 0x20 && text[text_offs] <= 0x2f) {
;
	jmp     L0066
L000F:	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$20
	bcc     L0014
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$30
	bcs     L0014
;
; text_tmp[text_offs] = 2*(text[text_offs]-0x20)+CHARA_OFFSET;
;
	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	clc
	adc     _text_offs
	bcc     L0018
	inx
L0018:	sta     sreg
	stx     sreg+1
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sec
	sbc     #$20
	asl     a
;
; } else {
;
	jmp     L0074
;
; text_tmp[text_offs] = 2*(text[text_offs]-0x40)+0x40+CHARA_OFFSET;
;
L0014:	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	clc
	adc     _text_offs
	bcc     L001C
	inx
L001C:	sta     sreg
	stx     sreg+1
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$40
	bcs     L001D
	dex
L001D:	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #$40
L0074:	clc
	adc     #$80
	ldy     #$00
	sta     (sreg),y
;
; for (text_offs = 0; text_offs<length; text_offs++) {
;
L0066:	inc     _text_offs
	jmp     L005E
;
; if (fast) {
;
L0003:	ldy     #$00
	lda     (sp),y
	beq     L0020
;
; vram_adr(address);
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_adr
;
; vram_write(text_tmp, length);
;
	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	jsr     pushax
	ldy     #$05
	ldx     #$00
	lda     (sp),y
	jsr     _vram_write
;
; } else {
;
	jmp     L0021
;
; set_vram_buffer();
;
L0020:	jsr     _set_vram_buffer
;
; multi_vram_buffer_horz(text_tmp, length, address);
;
	jsr     decsp3
	lda     #<(_text_tmp)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_text_tmp)
	sta     (sp),y
	ldy     #$06
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _multi_vram_buffer_horz
;
; if (!fast) ppu_wait_nmi();
;
L0021:	ldy     #$00
	lda     (sp),y
	bne     L0022
	jsr     _ppu_wait_nmi
;
; for (text_offs = 0; text_offs<length; text_offs++) {
;
L0022:	lda     #$00
	sta     _text_offs
L0067:	lda     _text_offs
	ldy     #$03
	cmp     (sp),y
	jcs     L0024
;
; if (text[text_offs] >= 0x30 && text[text_offs] <= 0x39) {
;
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$30
	bcc     L0027
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$3A
	bcs     L0027
;
; text_tmp[text_offs] = 2*(text[text_offs]-0x30)+0x20+1+CHARA_OFFSET;
;
	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	clc
	adc     _text_offs
	bcc     L002B
	inx
L002B:	sta     sreg
	stx     sreg+1
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$30
	bcs     L002C
	dex
L002C:	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #$20
;
; } else if (text[text_offs] >= 0x00 && text[text_offs] <= 0x1f) {
;
	jmp     L0077
L0027:	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$20
	bcs     L0031
;
; text_tmp[text_offs] = 0x00+CHARA_OFFSET;
;
	ldy     _text_offs
	lda     #$80
	sta     _text_tmp,y
;
; } else if (text[text_offs] >= 0x20 && text[text_offs] <= 0x2f) {
;
	jmp     L006F
L0031:	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$20
	bcc     L0036
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$30
	bcs     L0036
;
; text_tmp[text_offs] = 2*(text[text_offs]-0x20)+1+CHARA_OFFSET;
;
	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	clc
	adc     _text_offs
	bcc     L003A
	inx
L003A:	sta     sreg
	stx     sreg+1
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$20
	bcs     L003B
	dex
L003B:	stx     tmp1
	asl     a
	rol     tmp1
;
; } else {
;
	jmp     L0076
;
; text_tmp[text_offs] = 2*(text[text_offs]-0x40)+0x40+1+CHARA_OFFSET;
;
L0036:	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	clc
	adc     _text_offs
	bcc     L003F
	inx
L003F:	sta     sreg
	stx     sreg+1
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$40
	bcs     L0040
	dex
L0040:	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #$40
L0077:	bcc     L005D
L0076:	clc
L005D:	adc     #$01
	clc
	adc     #$80
	ldy     #$00
	sta     (sreg),y
;
; for (text_offs = 0; text_offs<length; text_offs++) {
;
L006F:	inc     _text_offs
	jmp     L0067
;
; if (fast) {
;
L0024:	ldy     #$00
	lda     (sp),y
	beq     L0044
;
; vram_adr(address+0x20);
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$20
	bcc     L0045
	inx
L0045:	jsr     _vram_adr
;
; vram_write(text_tmp, length);
;
	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	jsr     pushax
	ldy     #$05
	ldx     #$00
	lda     (sp),y
	jsr     _vram_write
;
; } else {
;
	jmp     L0046
;
; set_vram_buffer();
;
L0044:	jsr     _set_vram_buffer
;
; multi_vram_buffer_horz(text_tmp, length, address+0x20);
;
	jsr     decsp3
	lda     #<(_text_tmp)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_text_tmp)
	sta     (sp),y
	ldy     #$06
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$20
	bcc     L0047
	inx
L0047:	jsr     _multi_vram_buffer_horz
;
; }
;
L0046:	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ TestMode (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_TestMode: near

.segment	"CODE"

;
; pal_bg(MenuPal);
;
	lda     #<(_MenuPal)
	ldx     #>(_MenuPal)
	jsr     _pal_bg
;
; pal_spr(MenuPal_S);
;
	lda     #<(_MenuPal_S)
	ldx     #>(_MenuPal_S)
	jsr     _pal_spr
;
; vram_fill(0x80, 0x3c0);
;
	lda     #$80
	jsr     pusha
	ldx     #$03
	lda     #$C0
	jsr     _vram_fill
;
; render_title();
;
	jsr     _render_title
;
; DrawText("ROM TEST", 8, NTADR_A(10,9), 1);
;
	jsr     decsp5
	lda     #<(S000E)
	ldy     #$03
	sta     (sp),y
	iny
	lda     #>(S000E)
	sta     (sp),y
	lda     #$08
	ldy     #$02
	sta     (sp),y
	lda     #$2A
	ldy     #$00
	sta     (sp),y
	iny
	lda     #$21
	sta     (sp),y
	tya
	jsr     _DrawText
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; checking_sram = 1;
;
	lda     #$01
	sta     _checking_sram
;
; POKE(0x6003, 0x80);
;
	lda     #$80
	sta     $6003
;
; set_wram_mode(WRAM_ON);
;
	jsr     _set_wram_mode
;
; set_rand(PEEK(0x6000)+PEEK(0x6001)+1);
;
	ldx     #$00
	lda     $6000
	clc
	adc     $6001
	bcc     L000C
	inx
	clc
L000C:	adc     #$01
	bcc     L0002
	inx
L0002:	jsr     _set_rand
;
; if (checking_sram) {   
;
L0003:	lda     _checking_sram
	jeq     L0006
;
; sram_expected = rand8();
;
	jsr     _rand8
	sta     _sram_expected
;
; POKE(0x6000+sram_offset, sram_expected);
;
	lda     _sram_offset
	sta     ptr1
	lda     _sram_offset+1
	clc
	adc     #$60
	sta     ptr1+1
	lda     _sram_expected
	ldy     #$00
	sta     (ptr1),y
;
; if (PEEK(0x6000+sram_offset) != sram_expected) {
;
	lda     _sram_offset
	sta     ptr1
	lda     _sram_offset+1
	clc
	adc     #$60
	sta     ptr1+1
	lda     (ptr1),y
	cmp     _sram_expected
	beq     L0007
;
; checking_sram = 0;    
;
	sty     _checking_sram
;
; DrawText("SRAM FAIL", 9, NTADR_A(10,12), 0);    
;
	jsr     decsp5
	lda     #<(S000F)
	ldy     #$03
	sta     (sp),y
	iny
	lda     #>(S000F)
	sta     (sp),y
	lda     #$09
	ldy     #$02
	sta     (sp),y
	lda     #$8A
	ldy     #$00
	sta     (sp),y
	iny
	lda     #$21
	sta     (sp),y
	lda     #$00
	jsr     _DrawText
;
; set_wram_mode(WRAM_OFF);
;
	lda     #$40
	jsr     _set_wram_mode
;
; sram_offset++;
;
L0007:	inc     _sram_offset
	bne     L0008
	inc     _sram_offset+1
;
; if (sram_offset >= 0x2000) {
;
L0008:	lda     _sram_offset
	cmp     #$00
	lda     _sram_offset+1
	sbc     #$20
	bcc     L0003
;
; checking_sram = 0;
;
	lda     #$00
	sta     _checking_sram
;
; DrawText("SRAM PASS", 9, NTADR_A(10,12), 0);  
;
	jsr     decsp5
	lda     #<(S0010)
	ldy     #$03
	sta     (sp),y
	iny
	lda     #>(S0010)
	sta     (sp),y
	lda     #$09
	ldy     #$02
	sta     (sp),y
	lda     #$8A
	ldy     #$00
	sta     (sp),y
	iny
	lda     #$21
	sta     (sp),y
	lda     #$00
	jsr     _DrawText
;
; set_wram_mode(WRAM_OFF);  
;
	lda     #$40
	jsr     _set_wram_mode
;
; } else {
;
	jmp     L0003
;
; ppu_wait_nmi();
;
L0006:	jsr     _ppu_wait_nmi
;
; while (1) {
;
	jmp     L0003

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ IsCartridgeInserted (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_IsCartridgeInserted: near

.segment	"CODE"

;
; return !(PEEK(0x412d) & 0x1);
;
	lda     $412D
	and     #$01
	jsr     bnega
	ldx     #$00
;
; };
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ ClearCHRBlock (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ClearCHRBlock: near

.segment	"CODE"

;
; vram_adr(0x00);
;
	ldx     #$00
	txa
	jsr     _vram_adr
;
; for (gfx_offset = 0; gfx_offset<0x2000; gfx_offset++) {  
;
	lda     #$00
	sta     _gfx_offset
	sta     _gfx_offset+1
L0002:	ldx     _gfx_offset+1
	cpx     #$20
	bcs     L0003
;
; POKE(0x2007, 0xff);
;
	lda     #$FF
	sta     $2007
;
; for (gfx_offset = 0; gfx_offset<0x2000; gfx_offset++) {  
;
	inc     _gfx_offset
	bne     L0002
	inc     _gfx_offset+1
	jmp     L0002
;
; }
;
L0003:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ RunGame (unsigned int game)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_RunGame: near

.segment	"CODE"

;
; void RunGame(unsigned int game) { 
;
	jsr     pushax
;
; game += rom_shift;
;
	lda     _rom_shift
	ldx     _rom_shift+1
	jsr     addeq0sp
;
; set_prg_8000(ROM_OFFSETS);
;
	lda     #$38
	jsr     _set_prg_8000
;
; game_offset = (PEEK( 0x8001+(2*game) ) << 8) | PEEK( 0x8000+(2*game));
;
	ldy     #$01
	lda     (sp),y
	sta     tmp1
	dey
	lda     (sp),y
	asl     a
	rol     tmp1
	clc
	adc     #$01
	sta     ptr1
	lda     tmp1
	adc     #$80
	sta     ptr1+1
	lda     (ptr1),y
	sta     sreg+1
	iny
	lda     (sp),y
	sta     tmp1
	dey
	lda     (sp),y
	asl     a
	rol     tmp1
	sta     ptr1
	lda     tmp1
	clc
	adc     #$80
	sta     ptr1+1
	lda     (ptr1),y
	sta     _game_offset
	lda     sreg+1
	sta     _game_offset+1
;
; set_extended_gfx(0);
;
	tya
	jsr     _set_extended_gfx
;
; pal_clear();
;
	jsr     _pal_clear
;
; oam_clear();
;
	jsr     _oam_clear
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; ppu_off();
;
	jsr     _ppu_off
;
; disable_irq();   
;
	jsr     _disable_irq
;
; vram_adr(NTADR_A(0,0));
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_fill(0x00, 0x1000);   
;
	lda     #$00
	jsr     pusha
	ldx     #$10
	jsr     _vram_fill
;
; set_prg_8000(game >= 682 ? ROM_BANK+1 : ROM_BANK);
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	cmp     #$AA
	txa
	sbc     #$02
	bcc     L0004
	lda     #$3A
	jmp     L0005
L0004:	lda     #$39
L0005:	jsr     _set_prg_8000
;
; ClearCHRBlock();
;
	jsr     _ClearCHRBlock
;
; StartGame(game_offset);
;
	lda     _game_offset
	ldx     _game_offset+1
	jsr     _StartGame
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ render_title (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_render_title: near

.segment	"CODE"

;
; for (x_pos_ch = 0; x_pos_ch < 11; x_pos_ch++) {
;
	lda     #$00
	sta     _x_pos_ch
L001B:	lda     _x_pos_ch
	cmp     #$0B
	bcs     L001D
;
; set_vram_buffer();
;
	jsr     _set_vram_buffer
;
; for (x_pos_t = 0; x_pos_t<4; x_pos_t++) {
;
	lda     #$00
	sta     _x_pos_t
L001C:	lda     _x_pos_t
	cmp     #$04
	bcs     L0007
;
; title_buffer[x_pos_t] = (4*x_pos_ch)+x_pos_t;
;
	lda     #<(_title_buffer)
	ldx     #>(_title_buffer)
	clc
	adc     _x_pos_t
	bcc     L000A
	inx
L000A:	sta     ptr1
	stx     ptr1+1
	lda     _x_pos_ch
	asl     a
	asl     a
	clc
	adc     _x_pos_t
	ldy     #$00
	sta     (ptr1),y
;
; for (x_pos_t = 0; x_pos_t<4; x_pos_t++) {
;
	inc     _x_pos_t
	jmp     L001C
;
; multi_vram_buffer_vert(title_buffer, 4, NTADR_A(B_X_OFFS+x_pos_ch, B_Y_OFFS));
;
L0007:	jsr     decsp3
	lda     #<(_title_buffer)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_title_buffer)
	sta     (sp),y
	lda     #$04
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _x_pos_ch
	clc
	adc     #$07
	bcc     L000B
	inx
L000B:	ora     #$60
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_vert
;
; flush_vram_update2();
;
	jsr     _flush_vram_update2
;
; for (x_pos_ch = 0; x_pos_ch < 11; x_pos_ch++) {
;
	inc     _x_pos_ch
	jmp     L001B
;
; for (x_pos_ch = 0; x_pos_ch < 4; x_pos_ch++) {
;
L001D:	lda     #$00
	sta     _x_pos_ch
L001E:	lda     _x_pos_ch
	cmp     #$04
	bcs     L000D
;
; set_vram_buffer();
;
	jsr     _set_vram_buffer
;
; for (x_pos_t = 0; x_pos_t<4; x_pos_t++) {
;
	lda     #$00
	sta     _x_pos_t
L001F:	lda     _x_pos_t
	cmp     #$04
	bcs     L0011
;
; title_buffer[x_pos_t] = (4*x_pos_ch)+x_pos_t+0x2c;
;
	lda     #<(_title_buffer)
	ldx     #>(_title_buffer)
	clc
	adc     _x_pos_t
	bcc     L0014
	inx
L0014:	sta     ptr1
	stx     ptr1+1
	lda     _x_pos_ch
	asl     a
	asl     a
	clc
	adc     _x_pos_t
	clc
	adc     #$2C
	ldy     #$00
	sta     (ptr1),y
;
; for (x_pos_t = 0; x_pos_t<4; x_pos_t++) {
;
	inc     _x_pos_t
	jmp     L001F
;
; multi_vram_buffer_vert(title_buffer, 4, NTADR_A(B_X_OFFS+x_pos_ch+12, B_Y_OFFS));
;
L0011:	jsr     decsp3
	lda     #<(_title_buffer)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_title_buffer)
	sta     (sp),y
	lda     #$04
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _x_pos_ch
	clc
	adc     #$07
	bcc     L001A
	inx
	clc
L001A:	adc     #$0C
	bcc     L0017
	inx
L0017:	ora     #$60
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_vert
;
; flush_vram_update2();
;
	jsr     _flush_vram_update2
;
; for (x_pos_ch = 0; x_pos_ch < 4; x_pos_ch++) {
;
	inc     _x_pos_ch
	jmp     L001E
;
; vram_adr(0x23c0);
;
L000D:	ldx     #$23
	lda     #$C0
	jsr     _vram_adr
;
; vram_write(startup_attr, sizeof(startup_attr));
;
	lda     #<(_startup_attr)
	ldx     #>(_startup_attr)
	jsr     pushax
	ldx     #$00
	lda     #$40
	jmp     _vram_write

.endproc

; ---------------------------------------------------------------
; void __near__ ClearCHR (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ClearCHR: near

.segment	"CODE"

;
; for (gfx_bank_offset = 0; gfx_bank_offset<32; gfx_bank_offset++) {     
;
	lda     #$00
	sta     _gfx_bank_offset
L0013:	lda     _gfx_bank_offset
	cmp     #$20
	bcs     L0014
;
; set_chr_mode_0(8*gfx_bank_offset);
;
	asl     a
	asl     a
	asl     a
	jsr     _set_chr_mode_0
;
; set_chr_mode_1(8*gfx_bank_offset+2);
;
	lda     _gfx_bank_offset
	asl     a
	asl     a
	asl     a
	clc
	adc     #$02
	jsr     _set_chr_mode_1
;
; set_chr_mode_2(8*gfx_bank_offset+4);
;
	lda     _gfx_bank_offset
	asl     a
	asl     a
	asl     a
	clc
	adc     #$04
	jsr     _set_chr_mode_2
;
; set_chr_mode_3(8*gfx_bank_offset+5);
;
	lda     _gfx_bank_offset
	asl     a
	asl     a
	asl     a
	clc
	adc     #$05
	jsr     _set_chr_mode_3
;
; set_chr_mode_4(8*gfx_bank_offset+6);
;
	lda     _gfx_bank_offset
	asl     a
	asl     a
	asl     a
	clc
	adc     #$06
	jsr     _set_chr_mode_4
;
; set_chr_mode_5(8*gfx_bank_offset+7);
;
	lda     _gfx_bank_offset
	asl     a
	asl     a
	asl     a
	clc
	adc     #$07
	jsr     _set_chr_mode_5
;
; vram_adr(0x00);
;
	ldx     #$00
	txa
	jsr     _vram_adr
;
; for (gfx_offset = 0; gfx_offset<0x2000; gfx_offset++) {  
;
	lda     #$00
	sta     _gfx_offset
	sta     _gfx_offset+1
L000B:	ldx     _gfx_offset+1
	cpx     #$20
	bcs     L0004
;
; POKE(0x2007, 0xff);
;
	lda     #$FF
	sta     $2007
;
; for (gfx_offset = 0; gfx_offset<0x2000; gfx_offset++) {  
;
	inc     _gfx_offset
	bne     L000B
	inc     _gfx_offset+1
	jmp     L000B
;
; for (gfx_bank_offset = 0; gfx_bank_offset<32; gfx_bank_offset++) {     
;
L0004:	inc     _gfx_bank_offset
	jmp     L0013
;
; s_delay = 0x8;
;
L0014:	lda     #$08
	sta     _s_delay
;
; while (s_delay) {
;
	jmp     L0012
;
; s_delay--;
;
L0010:	dec     _s_delay
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; while (s_delay) {
;
L0012:	lda     _s_delay
	bne     L0010
;
; set_chr_mode_0(0);
;
	jsr     _set_chr_mode_0
;
; set_chr_mode_1(2);
;
	lda     #$02
	jsr     _set_chr_mode_1
;
; set_chr_mode_2(4);
;
	lda     #$04
	jsr     _set_chr_mode_2
;
; set_chr_mode_3(5);
;
	lda     #$05
	jsr     _set_chr_mode_3
;
; set_chr_mode_4(6);
;
	lda     #$06
	jsr     _set_chr_mode_4
;
; set_chr_mode_5(7);
;
	lda     #$07
	jmp     _set_chr_mode_5

.endproc

; ---------------------------------------------------------------
; void __near__ LoadGFX (int bank_id, int size)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_LoadGFX: near

.segment	"CODE"

;
; void LoadGFX(int bank_id, int size) { 
;
	jsr     pushax
;
; for (gfx_bank_offset = 0; gfx_bank_offset<size; gfx_bank_offset++) {   
;
	lda     #$00
	sta     _gfx_bank_offset
	tax
L0012:	lda     _gfx_bank_offset
	ldy     #$00
	cmp     (sp),y
	txa
	iny
	sbc     (sp),y
	bvc     L0011
	eor     #$80
L0011:	asl     a
	txa
	jcc     L0014
;
; set_prg_8000(bank_id+gfx_bank_offset);
;
	iny
	lda     (sp),y
	clc
	adc     _gfx_bank_offset
	jsr     _set_prg_8000
;
; set_chr_mode_0(8*gfx_bank_offset);
;
	lda     _gfx_bank_offset
	asl     a
	asl     a
	asl     a
	jsr     _set_chr_mode_0
;
; set_chr_mode_1(8*gfx_bank_offset+2);
;
	lda     _gfx_bank_offset
	asl     a
	asl     a
	asl     a
	clc
	adc     #$02
	jsr     _set_chr_mode_1
;
; set_chr_mode_2(8*gfx_bank_offset+4);
;
	lda     _gfx_bank_offset
	asl     a
	asl     a
	asl     a
	clc
	adc     #$04
	jsr     _set_chr_mode_2
;
; set_chr_mode_3(8*gfx_bank_offset+5);
;
	lda     _gfx_bank_offset
	asl     a
	asl     a
	asl     a
	clc
	adc     #$05
	jsr     _set_chr_mode_3
;
; set_chr_mode_4(8*gfx_bank_offset+6);
;
	lda     _gfx_bank_offset
	asl     a
	asl     a
	asl     a
	clc
	adc     #$06
	jsr     _set_chr_mode_4
;
; set_chr_mode_5(8*gfx_bank_offset+7);
;
	lda     _gfx_bank_offset
	asl     a
	asl     a
	asl     a
	clc
	adc     #$07
	jsr     _set_chr_mode_5
;
; vram_adr(0x00);
;
	ldx     #$00
	txa
	jsr     _vram_adr
;
; for (gfx_offset = 0; gfx_offset<0x2000; gfx_offset++) {  
;
	lda     #$00
	sta     _gfx_offset
	sta     _gfx_offset+1
L000B:	ldx     _gfx_offset+1
	cpx     #$20
	bcs     L0004
;
; POKE(0x2007, PEEK(0x8000+gfx_offset));
;
	lda     _gfx_offset
	sta     ptr1
	lda     _gfx_offset+1
	clc
	adc     #$80
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     $2007
;
; for (gfx_offset = 0; gfx_offset<0x2000; gfx_offset++) {  
;
	inc     _gfx_offset
	bne     L000B
	inc     _gfx_offset+1
	jmp     L000B
;
; for (gfx_bank_offset = 0; gfx_bank_offset<size; gfx_bank_offset++) {   
;
L0004:	ldx     #$00
	inc     _gfx_bank_offset
	jmp     L0012
;
; set_chr_mode_0(0);
;
L0014:	jsr     _set_chr_mode_0
;
; set_chr_mode_1(2);
;
	lda     #$02
	jsr     _set_chr_mode_1
;
; set_chr_mode_2(4);
;
	lda     #$04
	jsr     _set_chr_mode_2
;
; set_chr_mode_3(5);
;
	lda     #$05
	jsr     _set_chr_mode_3
;
; set_chr_mode_4(6);
;
	lda     #$06
	jsr     _set_chr_mode_4
;
; set_chr_mode_5(7);
;
	lda     #$07
	jsr     _set_chr_mode_5
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ LoadCat (char cat)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_LoadCat: near

.segment	"CODE"

;
; void LoadCat(char cat) {
;
	jsr     pusha
;
; d_cat = cat;
;
	ldy     #$00
	lda     (sp),y
	sta     _d_cat
;
; MAXGAME = CAT_NO[d_cat];
;
	ldx     #$00
	lda     _d_cat
	asl     a
	bcc     L0005
	inx
	clc
L0005:	adc     #<(_CAT_NO)
	sta     ptr1
	txa
	adc     #>(_CAT_NO)
	sta     ptr1+1
	iny
	lda     (ptr1),y
	sta     _MAXGAME+1
	dey
	lda     (ptr1),y
	sta     _MAXGAME
;
; rom_shift = CAT_SHF[d_cat];
;
	ldx     #$00
	lda     _d_cat
	asl     a
	bcc     L0006
	inx
	clc
L0006:	adc     #<(_CAT_SHF)
	sta     ptr1
	txa
	adc     #>(_CAT_SHF)
	sta     ptr1+1
	iny
	lda     (ptr1),y
	sta     _rom_shift+1
	dey
	lda     (ptr1),y
	sta     _rom_shift
;
; DrawText(CAT_TXT[d_cat], 8, NTADR_A(11, 7), 1);
;
	jsr     decsp5
	ldx     #$00
	lda     _d_cat
	asl     a
	bcc     L0007
	inx
	clc
L0007:	adc     #<(_CAT_TXT)
	sta     ptr1
	txa
	adc     #>(_CAT_TXT)
	sta     ptr1+1
	iny
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	ldy     #$03
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #$08
	ldy     #$02
	sta     (sp),y
	lda     #$EB
	ldy     #$00
	sta     (sp),y
	iny
	lda     #$20
	sta     (sp),y
	tya
	jsr     _DrawText
;
; DrawPage(0, 1);   
;
	lda     #$00
	jsr     pusha
	lda     #$01
	jsr     _DrawPage
;
; menu_offset = 0;
;
	lda     #$00
	sta     _menu_offset
	sta     _menu_offset+1
;
; page = 0;
;
	sta     _page
;
; m_d = 0;
;
	sta     _m_d
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; set_mirroring(MIRROR_VERTICAL);            
;
	lda     #$00
	jsr     _set_mirroring
;
; set_prg_8000(ROM_NAMETABLE+1);
;
	lda     #$35
	jsr     _set_prg_8000
;
; bank_spr(0);
;
	lda     #$00
	jsr     _bank_spr
;
; bank_bg(0);
;
	lda     #$00
	jsr     _bank_bg
;
; set_chr_mode_2(ROM_CHR);
;
	lda     #$00
	jsr     _set_chr_mode_2
;
; set_chr_mode_3(ROM_CHR+1);
;
	lda     #$01
	jsr     _set_chr_mode_3
;
; set_chr_mode_4(ROM_CHR+2);
;
	lda     #$02
	jsr     _set_chr_mode_4
;
; set_chr_mode_5(ROM_CHR+3);
;
	lda     #$03
	jsr     _set_chr_mode_5
;
; disable_irq();
;
	jsr     _disable_irq
;
; irq_array[0] = 0xff; // end of data 
;
	lda     #$FF
	sta     _irq_array
;
; memfill(digits, 0, 0x8);
;
	jsr     decsp3
	lda     #<(_digits)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_digits)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	tax
	lda     #$08
	jsr     _memfill
;
; ppu_off(); // screen off
;
	jsr     _ppu_off
;
; set_extended_gfx(X_GFX);
;
	lda     #$00
	jsr     _set_extended_gfx
;
; ClearCHR();
;
	jsr     _ClearCHR
;
; LoadGFX(0x20, 1);
;
	lda     #$20
	jsr     pusha0
	lda     #$01
	jsr     _LoadGFX
;
; pad1 = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; if ((pad1 & (PAD_A|PAD_B)) == (PAD_A|PAD_B)) {
;
	ldx     #$00
	and     #$C0
	cmp     #$C0
	bne     L0047
;
; TestMode();
;
	jsr     _TestMode
;
; PlaySnd(0);
;
L0047:	lda     #$00
	jsr     _PlaySnd
;
; d_cat = DEFAULT_CATEGORY;
;
	lda     #$00
	sta     _d_cat
;
; vram_adr(NTADR_A(0,0));
;
	ldx     #$20
	jsr     _vram_adr
;
; vram_fill(0x80, 0x3c0); 
;
	lda     #$80
	jsr     pusha
	ldx     #$03
	lda     #$C0
	jsr     _vram_fill
;
; pal_bg(MenuPal);
;
	lda     #<(_MenuPal)
	ldx     #>(_MenuPal)
	jsr     _pal_bg
;
; render_title();
;
	jsr     _render_title
;
; LoadCat(0);
;
	lda     #$00
	jsr     _LoadCat
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; pal_spr(MenuPal_S);
;
	lda     #<(_MenuPal_S)
	ldx     #>(_MenuPal_S)
	jsr     _pal_spr
;
; ppu_wait_nmi();
;
L0004:	jsr     _ppu_wait_nmi
;
; oam_clear();
;
	jsr     _oam_clear
;
; oam_spr(M_X, M_Y+(16*(menu_offset%MAXLINES)), ARR_OFFSET, 0x0);
;
	jsr     decsp3
	lda     #$30
	ldy     #$02
	sta     (sp),y
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$52
	ldy     #$01
	sta     (sp),y
	lda     #$B6
	dey
	sta     (sp),y
	tya
	jsr     _oam_spr
;
; oam_spr(M_X+8, M_Y+(16*(menu_offset%MAXLINES)), ARR_OFFSET+1, 0x0);
;
	jsr     decsp3
	lda     #$38
	ldy     #$02
	sta     (sp),y
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$52
	ldy     #$01
	sta     (sp),y
	lda     #$B7
	dey
	sta     (sp),y
	tya
	jsr     _oam_spr
;
; pad1 = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; pad1_new = get_pad_new(0);
;
	lda     #$00
	jsr     _get_pad_new
	sta     _pad1_new
;
; if (pad1_new & PAD_SELECT) {
;
	and     #$20
	beq     L0048
;
; ppu_off();
;
	jsr     _ppu_off
;
; d_cat = (d_cat + 1) & 1;
;
	lda     _d_cat
	clc
	adc     #$01
	and     #$01
	sta     _d_cat
;
; LoadCat(d_cat);
;
	jsr     _LoadCat
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; PlaySnd(0);
;
	lda     #$00
	jsr     _PlaySnd
;
; if (pad1_new & PAD_START) {
;
L0048:	lda     _pad1_new
	and     #$10
	beq     L004B
;
; while (pad1 & PAD_START) {pad1 = pad_poll(0);}
;
	jmp     L004A
L0049:	lda     #$00
	jsr     _pad_poll
	sta     _pad1
L004A:	lda     _pad1
	and     #$10
	bne     L0049
;
; RunGame(menu_offset);
;
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     _RunGame
;
; if (pad1 & PAD_RIGHT) {
;
L004B:	lda     _pad1
	and     #$01
	jeq     L004D
;
; PlaySnd(0);
;
	lda     #$00
	jsr     _PlaySnd
;
; menu_offset += MAXLINES;
;
	lda     #$08
	clc
	adc     _menu_offset
	sta     _menu_offset
	bcc     L0010
	inc     _menu_offset+1
;
; if (menu_offset >= MAXGAME) {
;
L0010:	lda     _menu_offset
	cmp     _MAXGAME
	lda     _menu_offset+1
	sbc     _MAXGAME+1
	bcc     L0014
;
; if (page >= MAXGAMES-1) {
;
	lda     _page
	jsr     pusha0
	lda     _MAXGAME
	ldx     _MAXGAME+1
	jsr     shrax3
	sec
	sbc     #$01
	bcs     L0013
	dex
L0013:	jsr     tosicmp
	bcc     L0012
;
; menu_offset = (menu_offset % MAXLINES);
;
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
;
; } else {
;
	jmp     L0015
;
; menu_offset = MAXGAME-1;
;
L0012:	lda     _MAXGAME
	ldx     _MAXGAME+1
	sec
	sbc     #$01
	bcs     L0015
	dex
L0015:	sta     _menu_offset
	stx     _menu_offset+1
;
; page = (menu_offset/MAXLINES);
;
L0014:	lda     _menu_offset
	ldx     _menu_offset+1
	cpx     #$00
	bpl     L0016
	sta     regsave
	stx     regsave+1
	cpx     #$FF
	bne     L0018
	cmp     #$F9
L0018:	jsr     boolult
	lsr     a
	lda     regsave
	ldx     regsave+1
	bcs     L0016
	lda     #$00
	jmp     L004C
L0016:	jsr     asrax3
L004C:	sta     _page
;
; DrawPage(page, 0);
;
	jsr     pusha
	lda     #$00
	jsr     _DrawPage
;
; m_d = menu_offset % MAXLINES;
;
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	sta     _m_d
;
; if (pad1 & PAD_LEFT) {  
;
L004D:	lda     _pad1
	and     #$02
	jeq     L004F
;
; PlaySnd(0);    
;
	lda     #$00
	jsr     _PlaySnd
;
; if (page <= 0) { 
;
	lda     _page
	bne     L001A
;
; menu_offset = (menu_offset % MAXLINES) + (MAXLINES * (MAXGAMES-1));
;
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	sta     ptr1
	stx     ptr1+1
	lda     _MAXGAME
	ldx     _MAXGAME+1
	jsr     shrax3
	sec
	sbc     #$01
	bcs     L001B
	dex
L001B:	jsr     shlax3
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	sta     _menu_offset
	stx     _menu_offset+1
;
; if (menu_offset >= MAXGAME) {
;
	cmp     _MAXGAME
	txa
	sbc     _MAXGAME+1
	bcc     L001E
;
; menu_offset = MAXGAME-1;
;
	lda     _MAXGAME
	ldx     _MAXGAME+1
	sec
	sbc     #$01
	bcs     L0062
	dex
;
; } else {
;
	jmp     L0062
;
; menu_offset = (menu_offset - MAXLINES) % MAXGAME;
;
L001A:	lda     _menu_offset
	ldx     _menu_offset+1
	sec
	sbc     #$08
	bcs     L001F
	dex
L001F:	jsr     pushax
	lda     _MAXGAME
	ldx     _MAXGAME+1
	jsr     tosumodax
L0062:	sta     _menu_offset
	stx     _menu_offset+1
;
; page = (menu_offset/MAXLINES);
;
L001E:	lda     _menu_offset
	ldx     _menu_offset+1
	cpx     #$00
	bpl     L0020
	sta     regsave
	stx     regsave+1
	cpx     #$FF
	bne     L0022
	cmp     #$F9
L0022:	jsr     boolult
	lsr     a
	lda     regsave
	ldx     regsave+1
	bcs     L0020
	lda     #$00
	jmp     L004E
L0020:	jsr     asrax3
L004E:	sta     _page
;
; DrawPage(page, 0);
;
	jsr     pusha
	lda     #$00
	jsr     _DrawPage
;
; m_d = menu_offset % MAXLINES;
;
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	sta     _m_d
;
; if (pad1_new & PAD_DOWN) {
;
L004F:	lda     _pad1_new
	and     #$04
	beq     L0050
;
; menu_hold_delay = 0;
;
	lda     #$00
	sta     _menu_hold_delay
;
; if ((pad1 & PAD_DOWN) && menu_hold_delay <= 0) {
;
L0050:	lda     _pad1
	and     #$04
	beq     L0058
	lda     _menu_hold_delay
	bne     L0058
;
; PlaySnd(0);
;
	jsr     _PlaySnd
;
; menu_offset++;
;
	inc     _menu_offset
	bne     L0028
	inc     _menu_offset+1
;
; m_d++;
;
L0028:	inc     _m_d
;
; if (menu_offset >= MAXGAME) {
;
	lda     _menu_offset
	cmp     _MAXGAME
	lda     _menu_offset+1
	sbc     _MAXGAME+1
	bcc     L0055
;
; if (page > 0) {
;
	lda     _page
	beq     L0046
;
; m_d = MAXLINES;
;
	lda     #$08
;
; m_d = 0;
;
L0046:	sta     _m_d
;
; menu_offset = 0;
;
	lda     #$00
	sta     _menu_offset
	sta     _menu_offset+1
;
; if (m_d >= MAXLINES) {
;
L0055:	lda     _m_d
	cmp     #$08
	bcc     L0057
;
; m_d = 0;
;
	lda     #$00
	sta     _m_d
;
; page = (menu_offset/MAXLINES);
;
	lda     _menu_offset
	ldx     _menu_offset+1
	cpx     #$00
	bpl     L002D
	sta     regsave
	stx     regsave+1
	cpx     #$FF
	bne     L002F
	cmp     #$F9
L002F:	jsr     boolult
	lsr     a
	lda     regsave
	ldx     regsave+1
	bcs     L002D
	lda     #$00
	jmp     L0056
L002D:	jsr     asrax3
L0056:	sta     _page
;
; DrawPage(page, 0);
;
	jsr     pusha
	lda     #$00
	jsr     _DrawPage
;
; menu_hold_delay = 8;
;
L0057:	lda     #$08
	sta     _menu_hold_delay
;
; if (pad1_new & PAD_UP) {
;
L0058:	lda     _pad1_new
	and     #$08
	beq     L0059
;
; menu_hold_delay = 0;
;
	lda     #$00
	sta     _menu_hold_delay
;
; if ((pad1 & PAD_UP) && menu_hold_delay <= 0) {
;
L0059:	lda     _pad1
	and     #$08
	jeq     L0031
	lda     _menu_hold_delay
	jne     L0031
;
; PlaySnd(0);
;
	jsr     _PlaySnd
;
; if (menu_offset <= 0) {
;
	lda     _menu_offset
	cmp     #$01
	lda     _menu_offset+1
	sbc     #$00
	bvc     L0036
	eor     #$80
L0036:	bpl     L0035
;
; menu_offset = MAXGAME-1;
;
	lda     _MAXGAME
	ldx     _MAXGAME+1
	sec
	sbc     #$01
	bcs     L0037
	dex
L0037:	sta     _menu_offset
	stx     _menu_offset+1
;
; m_d = m_d = (menu_offset % MAXLINES);
;
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	sta     _m_d
	sta     _m_d
;
; page = (menu_offset/MAXLINES);
;
	lda     _menu_offset
	ldx     _menu_offset+1
	cpx     #$00
	bpl     L0038
	sta     regsave
	stx     regsave+1
	cpx     #$FF
	bne     L003A
	cmp     #$F9
L003A:	jsr     boolult
	lsr     a
	lda     regsave
	ldx     regsave+1
	bcs     L0038
	lda     #$00
	jmp     L005D
L0038:	jsr     asrax3
L005D:	sta     _page
;
; if (page > 0) DrawPage(page, 0);    
;
	lda     _page
	beq     L0061
	jsr     pusha
	lda     #$00
	jsr     _DrawPage
;
; } else {
;
	jmp     L0061
;
; menu_offset--;
;
L0035:	lda     _menu_offset
	sec
	sbc     #$01
	sta     _menu_offset
	bcs     L005E
	dec     _menu_offset+1
;
; if (m_d <= 0) {
;
L005E:	lda     _m_d
	bne     L0060
;
; m_d = (menu_offset % MAXLINES);
;
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	sta     _m_d
;
; page = (menu_offset/MAXLINES);
;
	lda     _menu_offset
	ldx     _menu_offset+1
	cpx     #$00
	bpl     L003F
	sta     regsave
	stx     regsave+1
	cpx     #$FF
	bne     L0041
	cmp     #$F9
L0041:	jsr     boolult
	lsr     a
	lda     regsave
	ldx     regsave+1
	bcs     L003F
	lda     #$00
	jmp     L005F
L003F:	jsr     asrax3
L005F:	sta     _page
;
; DrawPage(page, 0);
;
	jsr     pusha
	lda     #$00
	jsr     _DrawPage
;
; } else {
;
	jmp     L0061
;
; m_d--;
;
L0060:	dec     _m_d
;
; menu_hold_delay = 8;
;
L0061:	lda     #$08
	sta     _menu_hold_delay
;
; if (menu_hold_delay) menu_hold_delay--;
;
L0031:	lda     _menu_hold_delay
	jeq     L0004
	dec     _menu_hold_delay
;
; while (1){ // infinite loop
;
	jmp     L0004

.endproc

